<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>算法 on Vtrily</title>
    <link>https://vtrily.github.io/categories/%E7%AE%97%E6%B3%95/</link>
    <description>Recent content in 算法 on Vtrily</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Mon, 06 Jan 2020 20:34:43 +0800</lastBuildDate>
    
	<atom:link href="https://vtrily.github.io/categories/%E7%AE%97%E6%B3%95/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>数组</title>
      <link>https://vtrily.github.io/2020/01/%E6%95%B0%E7%BB%84/</link>
      <pubDate>Mon, 06 Jan 2020 20:34:43 +0800</pubDate>
      
      <guid>https://vtrily.github.io/2020/01/%E6%95%B0%E7%BB%84/</guid>
      <description>数组 1.数组是什么？ 数组是一种占用连续内存空间的线性表数据结构。用于存储一组具有相同类型的数据。
关键词：线性表，连续内存空间，相同数据类型
优点：
查询快，通过下标支持随机访问，时间复杂度是O(1)
缺点:
添加和删除操作低效，为了要保证内存空间的连续性需要做数据搬移的操作。
数组和链表的区别
数组支持通过下标进行随机访问，时间复杂度是O(1)
2.为什么Java中数组的下标是从0开始的？ 这个问题需要研究一下数组的存储模型，因为数组是一中占用连续内存的数据结构
base + 下标 * 数据长度
如果说下标是从1开始的话，寻址公式就会变成
base + （下标 - 1） * 数据长度
这样CPU就会多进行一次减法运算，为了最大的利用CPU，所以Java中数组的下标从0开始
3.Java中数组和容器相比有什么优缺点 容器 优点 容器对数组的操作进行了封装，使用简单，重要的是容器实现了数组的自动扩容机制，数组扩容时不用手写复杂的扩容代码
Java中ArrayList初始化容量是10，容量不足时会按照
最大的容量是MAX_ARRAY_SIZE = Integer.MAX_VALUE（2^31-1） - 8
缺点 容器中只能包装对象，存在封箱拆箱的操作，占用内存大
数组 优点 占用内存少
缺点 没有自动扩容机制
扩容时需要手动实现数据搬移</description>
    </item>
    
    <item>
      <title>链表</title>
      <link>https://vtrily.github.io/2020/01/%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Mon, 06 Jan 2020 20:34:43 +0800</pubDate>
      
      <guid>https://vtrily.github.io/2020/01/%E9%93%BE%E8%A1%A8/</guid>
      <description>链表 1. 数组和链表的区别？ 数组的存储空间是连续的，可以借助CPU的缓存机制，预读数组中的数据，所以访问效率更高
数组的插入和删除时需要做大量的数据搬移，时间复杂度是O(n)
链表的存储空间可以是不连续的，对CPU缓存不友好，没办法有效预读
链表的插入和删除操作比较简单，它的时间复杂度是O(1)
但是链表随机访问的性能没有数组好，需要O(n)的时间复杂度
2.链表的分类 常见的链表有单向链表，双向链表，循环链表
链表通过指针将不连续的内存块串联在一起，其中，我们在这些内存块称为链表的结点。
为了将所有的结点串联起来，每个链表的结点不止要存储数据之外，还需要记录链表上的下一个结点的地址。
我们把记录下一个结点地址的指针叫做后继指针
头结点和尾结点
头结点记录的链表的基地址，单链表中尾结点指向的是一个空地址NULL
3.如何用链表实现LRU缓存淘汰算法？ 常见的缓存淘汰策略有：先进先出策略FIFO,最少使用策略LFU,最近最少使用策略LRU
实现缓存淘汰算法的思路
4.链表中的几个操作 单链表反转
链表中环的检测
两个有序的链表合并
删除链表倒数第n个结点
求链表的中间结点
单链表反转</description>
    </item>
    
  </channel>
</rss>